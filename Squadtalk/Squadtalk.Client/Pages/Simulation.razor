@page "/Canvas/Simulation"
@using Squadtalk.Client.Layout
@using Squadtalk.Client.Extensions
@using Squadtalk.Client.Data

@implements IAsyncDisposable
@layout CanvasLayout

<Modal @ref="_modal" Size="ModalSize.Small" />

<h3>Simulation</h3>
<p>
    <canvas id="canvas-simulation" width="600" height="600" style="border: 1px solid black"></canvas>
</p>

<h4>Rules</h4>

<div class="rules">
    <Button Class="add-rule" Color="ButtonColor.Success" @onclick="ShowRuleModal">Add rule</Button>
    @foreach (var rule in _rules)
    {
        <div class="rule">
            <div class="color-box" style="background: @rule.Attacker"></div>
            <div class="separator">â†’</div>
            <div class="color-box me-lg-2" style="background: @rule.Attacked"></div>
            
            <Button @onclick="() => RemoveRule(rule)" Color="ButtonColor.Danger" Outline="true" Size="Size.ExtraSmall" hidden="@(_rules.Count < 2)">x</Button>
        </div>
    }
</div>

<p>
    <Button @onclick="ToggleSimulation" Color="ButtonColor.Success">@_buttonText</Button>
    <div class="mt-2">
        <label class="form-label">Delay between steps (ms)</label>
        <NumberInput TValue="int" @bind-Value="@_delayMs" Max="500" Min="10" EnableMinMax="true" Step="5"/>
    </div>
    <div class="mt-2">
        <label class="form-label">Color change neighbour threshold</label>
        <NumberInput TValue="int" @bind-Value="@_threshold" Max="8" Min="1" EnableMinMax="true" Step="1"/>
    </div>
</p>


@inject IJSRuntime JSRuntime

@code {
    private const string Start = "Start";
    private const string Stop = "Stop";
    private const string Apply = "Apply";
    
    private int _delayMs = 100;
    private int _lastDelay;
    
    private int _threshold = 3;
    private int _lastThreshold;
    
    private IJSObjectReference _jsModule = default!;
    private string _buttonText = Start;
    private bool _running;
    
    private readonly PeriodicTimer _periodicTimer = new(TimeSpan.FromMilliseconds(100));
    private readonly List<Rule> _rules = [];
    private bool _rulesChanged;
    
    private Modal _modal = default!;
    private Dictionary<string, object> _parameters = default!;
    

    private void AddDefaultRules()
    {
        _rules.AddRange([
            new Rule(Color.Orange, Color.Yellow),
            new Rule(Color.Yellow, Color.Green),
            new Rule(Color.Green, Color.Orange)
        ]);
    }

    private Task CloseModal() => _modal.HideAsync();

    private Task AddRule(Rule rule)
    {
        if (_rules.Contains(rule))
        {
            return Task.CompletedTask;
        }

        _rulesChanged = true;
        _buttonText = Apply;
        _rules.Add(rule);
        
        StateHasChanged();

        return _modal.HideAsync();
    }

    private void RemoveRule(Rule rule)
    {
        _rules.Remove(rule);
        _rulesChanged = true;
        _buttonText = Apply;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        AddDefaultRules();
        
        _parameters = new Dictionary<string, object>
        {
            { "CancelCallback", EventCallback.Factory.Create(this, CloseModal) },
            { "AddRuleCallback", EventCallback.Factory.Create<Rule>(this, AddRule) }
        };
        
        _jsModule = await JSRuntime
            .InvokeAsync<IJSObjectReference>("import", "../js/Simulation.js");

        await _jsModule.InvokeVoidAsync("Init");
        await _jsModule.InvokeVoidAsync("SetRules", _rules);
    }
    
    private async Task ToggleSimulation()
    {
        if (_rulesChanged)
        {
            _rulesChanged = false;
            await _jsModule.InvokeVoidAsync("SetRules", _rules);
        }
        else
        {
            _running = !_running;
        }
        
        _buttonText = _running ? Stop : Start;

        if (_running)
        {
            _ = RunAsync();
        }
    }
    
    private async Task RunAsync()
    {
        while (await _periodicTimer.WaitForNextTickAsync())
        {
            if (!_running) break;
            await _jsModule.InvokeVoidAsync("Step");

            if (_lastDelay != _delayMs)
            {
                _periodicTimer.Period = TimeSpan.FromMilliseconds(_delayMs);
                _lastDelay = _delayMs;
            }

            if (_lastThreshold != _threshold)
            {
                await _jsModule.InvokeVoidAsync("UpdateThreshold", _threshold);
                _lastThreshold = _threshold;
            }
        }
    }

    public ValueTask DisposeAsync()
    {
        _periodicTimer.Dispose();
        return _jsModule.TryDisposeAsync();
    }

    private Task ShowRuleModal()
    {
        return _modal.ShowAsync<RuleCreatorDialog>("Add New Rule", parameters: _parameters);
    }
}